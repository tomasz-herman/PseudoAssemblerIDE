apply=Zastosuj
background=tło
brackets=nawiasy
cancel=Anuluj
close=Zamknij
colors=Kolory
comment=komentarz
current.line=obecna linia
data.type=typ danych
declaration=deklaracja
editor.color.scheme=Schemat kolorów edytora
editor.font=Czcionka edytora
editor.font.size=Rozmiar czcionki edytora
error.quoted=niepoprawnie cytowane
font=Czcionka
function=funkcja
function.2=funkcja 2
general=Ogólne
gutter=rynna
label=etykieta
number=liczba
ok=Ok
operator=operator
quoted=cytowane
selected.text=zaznaczony tekst
selection=zaznaczenie
show.icon.row.header=pokazuj kolumnę na ikonki
show.line.numbers=pokazuj numery linii
terminal.color.scheme=Schemat kolorów terminala
terminal.font=Czcionka terminala
terminal.font.size=Rozmiar czcionki terminala
text=tekst
wrap.lines=zawijaj linie
new=Nowy
open...=Otwórz...
save=Zapisz
save.as...=Zapisz jako...
settings...=Ustawienia...
exit=Wyjdź
undo=Cofnij
redo=Powtórz
cut=Wytnij
copy=Kopiuj
paste=Wklej
delete=Usuń
select.all=Zaznacz wszystko
assemble=Assembluj
assemble.and.load=Assembluj i wczytaj
run=Uruchom
debug=Debuguj
print.stack=Wydrukuj stos
print.gpr=Wydrukuj rejestr
print.fpr=Wydrukuj rejestr zm-p.
help...=Pomoc...
license...=Licencja...
about...=O programie...
file=Plik
help=Pomoc
edit=Edytuj
settings=Ustawienia
license=Licencja
about=O programie
some.program.is.already.running.do.you.wish.to.stop.it=Jakiś program jest już uruchomiony! Czy chiałbyś go zatrzymać?
some.program.is.running=Jakiś program jest uruchomiony
choose.color=Wybierz kolor
about.text=<h1 style="font-size:32;">Pseudo-Assembler IDE</h1>\
<pre style="font-size:18;">\
Zasilane oprogramowaniem typu open-source\n\
<a href="https://github.com/tomasz-herman/PseudoAssemblerEmulator">Pseudo-Assembler Emulator</a> wersja: 3.1.6, dostępne na licencji <a href="https://github.com/tomasz-herman/PseudoAssemblerEmulator/blob/master/LICENSE">MIT License</a>\n\
<a href="https://github.com/bobbylight/RSyntaxTextArea">RSyntaxTextArea</a> wersja: 3.0.8, dostępne na licencji <a href="https://github.com/bobbylight/RSyntaxTextArea/blob/master/RSyntaxTextArea/src/main/resources/META-INF/LICENSE">BSD 3-Clause license</a>\n\
<a href="https://github.com/JFormDesigner/FlatLaf">FlatLaf</a> wersja: 0.24, dostępne na licencji <a href="https://github.com/JFormDesigner/FlatLaf/blob/master/LICENSE">Apache 2.0 License</a>\n\
Źródła dostępne na <a href="https://github.com/tomasz-herman/PseudoAssemblerIDE">Githubie</a>\n\
Copyright (c) 2019-2020 Tomasz Herman, Emil Dragańczuk\n\
</pre>
license.text=<pre style="font-size:18;">\
Copyright (c) 2019-2020 Tomasz Herman, Emil Dragańczuk\n\
\n\
Permission is hereby granted, free of charge, to any person obtaining a copy\n\
of this software and associated documentation files (the "Software"), to deal\n\
in the Software without restriction, including without limitation the rights\n\
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\
copies of the Software, and to permit persons to whom the Software is\n\
furnished to do so, subject to the following conditions:\n\
\n\
The above copyright notice and this permission notice shall be included in all\n\
copies or substantial portions of the Software.\n\
\n\
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\
SOFTWARE.\
</pre>
help.text=<pre style="font-size:18;">\
Ogólne skróty klawiszowe:\n\
        Ctrl + S  - Zapisz\n\
        Ctrl + O  - Otwórz\n\
        Ctrl + N  - Nowy\n\
        Ctrl + F5 - Uruchom\n\
Shift + Ctrl + F5 - Debuguj\n\
               F5 - Assembluj\n\
Shift        + F5 - Assembluj i wczytaj\n\
Skróty klawiszowe terminala:\n\
        Ctrl + C  - Wyślij sygnał SIGINT\n\
Shift + Ctrl + C  - Kopiuj\n\
Skróty klawiszowe edytora:\n\
        Ctrl + Z  - Ponów\n\
        Ctrl + Y  - Cofnij\n\
        Ctrl + A  - Zaznacz wszystko\n\
        Ctrl + C  - Kopiuj\n\
        Ctrl + V  - Wklej\n\
        Ctrl + X  - Wytnij\n\
        Ctrl + Spacja - Autouzupełnienie\n\
Po dalszą pomoc odwołaj się do podręcznika użytkownika: <a href="https://github.com/tomasz-herman/PseudoAssemblerEmulator/raw/master/docs/reference_manual_pl.pdf/">POBIERZ</a>
save.changes.before.closing=Zapisać zmiany przed zamknięciem?
pusha.short=
fpusha.short=
popa.short=
fpopa.short=
enter.short=
leave.short=
ld.short=
fld.short=
st.short=
fst.short=
lda.short=
out.short=
bout.short=
cout.short=
iout.short=
fout.short=
nop.short=
xchg.short=
fxch.short=
ldb.short=
ldbu.short=
stb.short=
fild.short=
fist.short=
rand.short=
halt.short=
time.short=
in.short=
sleep.short=
push.short=
fpush.short=
pop.short=
fpop.short=
pushf.short=
popf.short=
add.short=Dodaje dwie liczby całkowite
sub.short=
mul.short=
div.short=
idiv.short=
cmp.short=
fadd.short=
fsub.short=
fmul.short=
fdiv.short=
fcmp.short=
neg.short=
inc.short=
dec.short=
fsqrt.short=
fabs.short=
fsin.short=
fcos.short=
ftan.short=
fxam.short=
ftst.short=
and.short=
or.short=
xor.short=
test.short=
not.short=
shr.short=
shl.short=
sar.short=
sal.short=
ror.short=
rol.short=
jmp.short=
je.short=
jz.short=
jne.short=
jnz.short=
jg.short=
jnle.short=
jge.short=
jnl.short=
jl.short=
jnge.short=
jle.short=
jng.short=
ja.short=
jnbe.short=
jae.short=
jnb.short=
jnc.short=
jb.short=
jnae.short=
jc.short=
jbe.short=
jna.short=
jo.short=
jno.short=
js.short=
jns.short=
jp.short=
jnp.short=
loop.short=
call.short=
exit.short=Wyjdź
ret.short=Powraca z procedury
dc.short=Zadeklaruj stałą
ds.short=Zarezerwuj pamięć
float.short=
integer.short=
string.short=
char.short=
byte.short=
pusha.summary=<h1>PUSHA</h1>\
Wrzuca wszystkie rejestry ogólnego zastosowania na stos w kolejności 0, 1, 2, ..., 11(stara wartość), 12, \
13, 14, 15. Zamiast ESP na stos wrzucana jest wartość sprzed wywołania Instrukcji PUSHA.\
<h3>Operacja</h3>\
TEMP = ESP;<br />\
STACK.PUSH(REG0);<br />\
STACK.PUSH(REG1);<br />\
STACK.PUSH(REG2);<br />\
...<br />\
STACK.PUSH(REG10);<br />\
STACK.PUSH(TEMP);<br />\
STACK.PUSH(REG12);<br />\
STACK.PUSH(REG13);<br />\
STACK.PUSH(REG14);<br />\
STACK.PUSH(REG15);\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fpusha.summary=<h1>FPUSHA</h1>\
Wrzuca wszystkie rejestry zmiennoprzecinkowe na stos w kolejności 0, 1, 2, ..., 14, 15.\
<h3>Operacja</h3>\
STACK.PUSH(FPR0);<br />\
STACK.PUSH(FPR1);<br />\
STACK.PUSH(FPR2);<br />\
...<br />\
STACK.PUSH(FPR14);<br />\
STACK.PUSH(FPR15);\
<h3>Modyfikowane Flagi</h3>\
Żadne.
popa.summary=<h1>POPA</h1>\
Zdejmuje wszystkie rejestry ogólnego zastosowania ze stosu w kolejności 15, 14, 13, 12, 10, 9, ..., 2, 1, 0. \
Wartość rejestru ESP jest ignorowana, zamiast zdjęcia jej ze stosu, ESP jest zwiększane o cztery.\
<h3>Operacja</h3>\
REG15 = STACK.POP();<br />\
REG14 = STACK.POP();<br />\
REG13 = STACK.POP();<br />\
REG12 = STACK.POP();<br />\
ESP = ESP + 4; (*Pomiń 4 bajty stosu*)<br />\
REG10 = STACK.POP();<br />\
...<br />\
REG2 = STACK.POP();<br />\
REG1 = STACK.POP();<br />\
REG0 = STACK.POP();\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fpopa.summary=<h1>FPOPA</h1>\
Po kolei zdejmuje ze stosu i umieszcza w rejestrach zmiennoprzecinkowych liczby w kolejności 15, 14, ..., \
2, 1, 0.\
<h3>Operacja</h3>\
FPR15 = STACK.POP();<br />\
FPR14 = STACK.POP();<br />\
...<br />\
FPR2 = STACK.POP();<br />\
FPR1 = STACK.POP();<br />\
FPR0 = STACK.POP();\
<h3>Modyfikowane Flagi</h3>\
Żadne.
enter.summary=<h1>ENTER</h1>\
Tworzy ramkę stosu dla procedury. Instrukcje ENTER i LEAVE są przeznaczone do organizacji kodu w bloki \
podobnie do języków wyższego poziomu. Typowo instrukcja ENTER jest pierwszą instrukcją procedury, \
tworzącą dla niej nową ramkę stosu. Instrukcja LEAVE jest zwykle używane na końcu procedury(tuż przed \
instrukcją RET), żeby zwolnić stworzoną ramkę.\
<h3>Operacja</h3>\
STACK.PUSH(EBP);\
<br />\
EBP = ESP;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
leave.summary=<h1>LEAVE</h1>\
Zwalnia ramkę stosu stworzoną wcześniej przez instrukcję ENTER. Instrukcja LEAVE kopiuje ramkę \
stosu(EBP) do rejstru wkaźnika stosu(ESP), co zwalnia tym samym miejsce rezerwowane przez ramkę. \
Stara ramka stosu jest następnie zdejmowana z nowego szczytu stosu, co przywraca oryginalną ramkę \
stosu.<br />\
Zazwyczaj następną instrukcją po LEAVE jest instrukcja RET, przywracająca sterowanie do wywołującej \
procedury.\
<h3>Operacja</h3>\
ESP = EBP;<br />\
EBP = STACK.POP();\
<h3>Modyfikowane Flagi</h3>\
Żadne.
ld.summary=<h1>LD</h1>\
Wczytuje liczbę podaną w drugim argumencie(źródłowy) i umieszcza ją w rejestrze podanym w \
pierwszym argumencie(wynikowy) . Wynikowy argument może być wyłącznie rejestrem. Źródłowy \
argument może być rejestrem albo miejscem w pamięci.\
<h3>Operacja</h3>\
ARG1 = ARG2;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fld.summary=<h1>FLD</h1>\
Wczytuje liczbę podaną w drugim argumencie(źródłowy) i umieszcza ją w rejestrze \
zmiennoprzecinkowym podanym w drugim argumencie(wynikowy) . Wynikowy argument może być \
wyłącznie rejestrem zmiennoprzecinkowym. Źródłowy argument może być rejestrem \
zmiennoprzecinkowym albo miejscem w pamięci.\
<h3>Operacja</h3>\
ARG1 = ARG2;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
st.summary=<h1>ST</h1>\
Umieszcza liczbę podaną w pierwszym argumencie(źródłowy) w drugim argumencie(wynikowy). \
Źródłowy argument może być wyłącznie rejestrem. Wynikowy argument może być wyłącznie miejscem w \
pamięci.\
<h3>Operacja</h3>\
ARG2 = ARG1;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fst.summary=<h1>FST</h1>\
Umieszcza liczbę zmiennoprzecinkową podaną w pierwszym argumencie(źródłowy) w drugim \
argumencie(wynikowy). Źródłowy argument może być wyłącznie rejestrem zmiennoprzecinkowym. \
Wynikowy argument może być wyłącznie miejscem w pamięci.\
<h3>Operacja</h3>\
ARG2 = ARG1;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
lda.summary=<h1>LDA</h1>\
Wczytuje adres podany w drugim argumencie(źródłowy) i umieszcza go w rejestrze podanym w \
pierwszym argumencie(wynikowy) . Wynikowy argument może być wyłącznie rejestrem. Źródłowy \
argument może być rejestrem albo miejscem w pamięci.\
<h3>Operacja</h3>\
ARG1 = ADDRESS(ARG2);\
<h3>Modyfikowane Flagi</h3>\
Żadne.
out.summary=<h1>OUT</h1>\
Wypisuje argument na ekran jako liczbę całkowitą bez znaku. Argumentem może być rejestr albo miejsce \
w pamięci.\
<h3>Operacja</h3>\
OUT (UNSIGNED)ARG1;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
bout.summary=<h1>BOUT</h1>\
Wypisuje najmłodszy bajt argumentu na ekran. Argumentem może być rejestr albo miejsce w pamięci.\
<h3>Operacja</h3>\
OUT (BYTE)ARG1;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
cout.summary=<h1>COUT</h1>\
Wypisuje najmłodszy bajt argumentu na ekran jako znak. Używane jest kodowanie ASCII. Argumentem \
może być rejestr albo miejsce w pamięci.\
<h3>Operacja</h3>\
OUT (CHAR)ARG1;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
iout.summary=<h1>IOUT</h1>\
Wypisuje argument na ekran jako liczbę całkowitą ze znakiem. Argumentem może być rejestr albo \
miejsce w pamięci.\
<h3>Operacja</h3>\
OUT (SIGNED)ARG1\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fout.summary=<h1>FOUT</h1>\
Wypisuje argument na ekran jako liczbę zmiennoprzecinkową. Argumentem może być rejestr \
zmiennoprzecinkowy albo miejsce w pamięci.\
<h3>Operacja</h3>\
OUT (FLOAT)ARG1\
<h3>Modyfikowane Flagi</h3>\
Żadne.
nop.summary=<h1>NOP</h1>\
Nic nie robi.\
<h3>Operacja</h3>\
<h3>Modyfikowane Flagi</h3>\
Żadne.
xchg.summary=<h1>XCHG</h1>\
Zamienia miejscami wartości między pierwszym argumentem źródłowym a drugim argumentem. \
Pierwszy argument może być wyłącznie rejestrem. Drugi argument może być rejestrem albo miejscem w \
pamięci.\
<h3>Operacja</h3>\
TEMP = ARG1;<br />\
ARG1 = ARG2;<br />\
ARG2 = TEMP;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fxch.summary=<h1>FXCH</h1>\
Zamienia miejscami wartości między pierwszym argumentem źródłowym a drugim argumentem. \
Pierwszy argument może być wyłącznie rejestrem zmiennoprzecinkowym. Drugi argument może być \
rejestrem zmiennoprzecinkowym albo miejscem w pamięci.\
<h3>Operacja</h3>\
TEMP = ARG1;<br />\
ARG1 = ARG2;<br />\
ARG2 = TEMP;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
ldb.summary=<h1>LDB</h1>\
Wczytuje najmłodszy liczby podanej w drugim argumencie(źródłowy) i umieszcza ją w rejestrze podanym \
w drugim argumencie(wynikowy) . Wynikowy argument może być wyłącznie rejestrem. Źródłowy \
argument może być wyłącznie miejscem w pamięci. Pozostałe bajty są uzupełniane znakiem wczytanego \
bajtu.\
<h3>Operacja</h3>\
ARG1 = (BYTE)ARG2\
<h3>Modyfikowane Flagi</h3>\
Żadne.
ldbu.summary=<h1>LDBU</h1>\
Wczytuje najmłodszy liczby podanej w drugim argumencie(źródłowy) i umieszcza ją w rejestrze podanym \
w drugim argumencie(wynikowy) . Wynikowy argument może być wyłącznie rejestrem. Źródłowy \
argument może być wyłącznie miejscem w pamięci. Pozostałe bajty są uzupełniane zerem.\
<h3>Operacja</h3>\
ARG1 = (BYTE)ARG2\
<h3>Modyfikowane Flagi</h3>\
Żadne.
stb.summary=<h1>STB</h1>\
Umieszcza najmłodszy bajt liczby podanej w pierwszym argumencie(źródłowy) w drugim \
argumencie(wynikowy). Źródłowy argument może być wyłącznie rejestrem. Wynikowy argument może \
być wyłącznie miejscem w pamięci.\
<h3>Operacja</h3>\
ARG2 = (BYTE)ARG1\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fild.summary=<h1>FILD</h1>\
Wczytuje liczbę całkowitą podaną w drugim argumencie(źródłowy), konwertuje ją do liczby \
zmiennoprzecinkowej i umieszcza ją w rejestrze zmiennoprzecinkowym podanym w drugim \
argumencie(wynikowy) . Wynikowy argument może być wyłącznie rejestrem zmiennoprzecinkowym. \
Źródłowy argument może być wyłącznie miejscem w pamięci.\
<h3>Operacja</h3>\
ARG1 = (FLOAT)ARG2\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fist.summary=<h1>FIST</h1>\
Konwertuje liczbę zmiennoprzecinkową podaną w pierwszym argumencie(źródłowy) na liczbę całkowitą i \
umieszcza ją w drugim argumencie(wynikowy). Źródłowy argument może być wyłącznie rejestrem \
zmiennoprzecinkowym. Wynikowy argument może być wyłącznie miejscem w pamięci.<br />\
Jeżeli źródłowy argument nie jest liczbą całkowitą, to wartość niecałkowita jest ucinana.\
<h3>Operacja</h3>\
ARG2 = (INT)ARG1\
<h3>Modyfikowane Flagi</h3>\
Żadne.
rand.summary=<h1>RAND</h1>\
Losuje liczbę całkowitą i umieszcza ją w argumencie wynikowym. Argument może być rejestrem albo \
miejscem w pamięci.\
<h3>Operacja</h3>\
ARG1 = RAND;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
halt.summary=<h1>HALT</h1>\
Wstrzymuje pracę komputera. Praca jest wznawiana wraz z naciśnięciem klawisza RETURN.\
<h3>Operacja</h3>\
HALT;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
time.summary=<h1>TIME</h1>\
Zapisuje czas, który upłynął od 01.01.1970 roku mierzony w sekundach w argumencie wynikowym. \
Dodatkowo w rejestrze ósmym przechowywana jest liczba milisekund która upłynęła od tego dnia \
modulo 1000. Argument może być rejestrem albo miejscem w pamięci.\
<h3>Operacja</h3>\
ARG1 = TIME_IN_SECONDS;<br />\
REG8 = TIME_IN_MILLIS mod 1000;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
in.summary=<h1>IN</h1>\
Wczytuje znak z klawiatury i umieszcza go w najmłodszym bicie argumentu. Argumentem może być \
rejestr lub miejsce w pamięci. Jeżeli argumentem jest rejestr to pozostałe bajty są ustawiane znakiem \
najmłodszego bajtu.\
<h3>Operacja</h3>\
ARG1 = INPUT;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
sleep.summary=<h1>SLEEP</h1>\
Czeka liczbę sprecyzowaną w argumencie źródłowym milisekund. Argument może być rejestrem albo \
miejscem w pamięci.\
<h3>Operacja</h3>\
SLEEP(ARG1);\
<h3>Modyfikowane Flagi</h3>\
Żadne.
push.summary=<h1>PUSH</h1>\
Wrzuca na stos argumentu źródłowy. Źródłowy argument może być rejestrem albo miejscem w pamięci.\
<h3>Operacja</h3>\
STACK.PUSH(ARG1);\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fpush.summary=<h1>FPUSH</h1>\
Wrzuca na stos argumentu źródłowy. Źródłowy argument może być rejestrem zmiennoprzecinkowym \
albo miejscem w pamięci.\
<h3>Operacja</h3>\
STACK.PUSH(ARG1);\
<h3>Modyfikowane Flagi</h3>\
Żadne.
pop.summary=<h1>POP</h1>\
Zdejmuje wartość ze stosu i umieszcza ją w argumencie wynikowym. Wynikowy argument może być \
rejestrem albo miejscem w pamięci.\
<h3>Operacja</h3>\
ARG1 = STACK.POP();\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fpop.summary=<h1>FPOP</h1>\
Zdejmuje wartość ze stosu i umieszcza ją w argumencie wynikowym. Wynikowy argument może być \
rejestrem zmiennoprzecinkowym albo miejscem w pamięci.\
<h3>Operacja</h3>\
ARG1 = STACK.POP();\
<h3>Modyfikowane Flagi</h3>\
Żadne.
pushf.summary=<h1>PUSHF</h1>\
Wrzuca wartość rejestru flag na stos. Rejestr flag to liczba 4 bajtowa w której poszczególne bity oznaczają \
flagi(patrz tabela niżej).\
<br />\
<table >\
<tbody>\
<tr>\
<td> Flaga </td>\
<td> CF </td>\
<td> PF </td>\
<td> ZF </td>\
<td> SF </td>\
<td> OF </td>\
</tr>\
<tr>\
<td> Numer bitu </td>\
<td> 1 </td>\
<td> 3 </td>\
<td> 7 </td>\
<td> 8 </td>\
<td> 12 </td>\
</tr>\
</tbody>\
</table>\
<h3>Operacja</h3>\
STACK.PUSH(FLAGS);\
<h3>Modyfikowane Flagi</h3>\
Żadne.
popf.summary=<h1>POPF</h1>\
Zrzuca ze stosu wartość i umieszcza ją w rejestrze flag. Rejestr flag to liczba 4 bajtowa w której \
poszczególne bity oznaczają flagi(patrz tabela niżej).\
<br />\
<table >\
<tbody>\
<tr>\
<td> Flaga </td>\
<td> CF </td>\
<td> PF </td>\
<td> ZF </td>\
<td> SF </td>\
<td> OF </td>\
</tr>\
<tr>\
<td> Numer bitu </td>\
<td> 1 </td>\
<td> 3 </td>\
<td> 7 </td>\
<td> 8 </td>\
<td> 12 </td>\
</tr>\
</tbody>\
</table>\
<h3>Operacja</h3>\
FLAGS = STACK.POP();\
<h3>Modyfikowane Flagi</h3>\
Wszystkie, patrz opis.
add.summary=<h1>ADD</h1>\
Dodaje pierwszy argument(wynikowy) do drugiego argumentu(źródłowy) a następnie przechowuje \
wynik w argumencie wynikowym. Wynikowy argument może być wyłącznie rejestrem; źródłowy \
argument może być rejestrem albo miejscem w pamięci.\
<br />\
Instrukcja ADD wykonuje dodawanie całkowitoliczbowe. Wykonuje obliczenia zarówno dla liczb \
całkowitoliczbowych ze znakiem jak i bez znaku i ustawia flagi CF oraz OF żeby zasygnalizować \
przeniesienie (przepełnienie) odpowiednio w znakowym jak i bez znakowym wyniku. Flaga SF \
sygnalizuje znak wyniku.\
<h3>Operacja</h3>\
ARG1 = ARG1 + ARG2;\
<h3>Modyfikowane Flagi</h3>\
Flagi OF, SF, ZF, CF i PF są ustawione w zależności od wyniku.
sub.summary=<h1>SUB</h1>\
Odejmuje drugi argument(źródłowy) od pierwszego argumentu(wynikowy) a następnie przechowuje \
wynik w argumencie wynikowym. Wynikowy argument może być wyłącznie rejestrem; źródłowy \
argument może być rejestrem albo miejscem w pamięci.<br />\
Instrukcja SUB wykonuje odejmowanie całkowitoliczbowe. Wykonuje obliczenia zarówno dla liczb \
całkowitoliczbowych ze znakiem jak i bez znaku i ustawia flagi CF oraz OF żeby zasygnalizować \
przeniesienie (przepełnienie) odpowiednio w znakowym jak i bez znakowym wyniku. Flaga SF \
sygnalizuje znak wyniku. \
<h3>Operacja</h3>\
ARG1 = ARG1 - ARG2;\
<h3>Modyfikowane Flagi</h3>\
Flagi OF, SF, ZF, CF i PF są ustawione w zależności od wyniku.
mul.summary=<h1>MUL</h1>\
Mnoży pierwszy argument(wynikowy) przez drugi argument(źródłowy) a następnie przechowuje wynik w \
argumencie wynikowym. Wynikowy argument może być wyłącznie rejestrem; źródłowy argument może \
być rejestrem albo miejscem w pamięci.<br />\
Przepełnienie jest sygnalizowane przez ustawienie flag CF i OF na 1, przy braku przepełnienia flagi te \
ustawiane są na 0.\
<h3>Operacja</h3>\
ARG1 = ARG1 · ARG2;\
<h3>Modyfikowane Flagi</h3>\
Flagi OF i CF są ustawiane na 1, gdy przepełnienie, w przeciwnym przypadku ustawiane na 0. Flagi SF, ZF \
i PF nie są modyfikowane.
div.summary=<h1>DIV</h1>\
Dzieli bez znaku pierwszy argument(wynikowy) przez drugi argument(źródłowy) a następnie \
przechowuje wynik w argumencie wynikowym, reszta z dzielenia przechowywana jest w rejestrze \
ósmym. Wynikowy argument może być wyłącznie rejestrem; źródłowy argument może być rejestrem \
albo miejscem w pamięci.\
<br />\
Niecałkowita część wyniku jest przycinana do zera. Reszta z dzielenia jest zawsze mniejsza od dzielnika. \
Błąd dzielenia jest sygnalizowany przez ustawienie flag CF i OF na 1, przy braku błędu flagi te ustawiane \
są na 0.\
<h3>Operacja</h3>\
ARG1 = ARG1 / ARG2;\
<br />\
REG8 = ARG1 mod ARG2;\
<h3>Modyfikowane Flagi</h3>\
Flagi OF i CF są ustawiane na 1, gdy dzielnik to 0, w przeciwnym przypadku ustawiane na 0. Flagi SF, ZF i \
PF nie są modyfikowane.
idiv.summary=<h1>IDIV</h1>\
Dzieli ze znakiem pierwszy argument(wynikowy) przez drugi argument(źródłowy) a następnie \
przechowuje wynik w argumencie wynikowym, reszta z dzielenia przechowywana jest w rejestrze \
ósmym. Wynikowy argument może być wyłącznie rejestrem; źródłowy argument może być rejestrem \
albo miejscem w pamięci.<br />\
Niecałkowita część wyniku jest przycinana do zera. Reszta z dzielenia jest zawsze mniejsza od dzielnika. \
Błąd dzielenia jest sygnalizowany przez ustawienie flag CF i OF na 1, przy braku błędu flagi te ustawiane \
są na 0.\
<h3>Operacja</h3>\
ARG1 = ARG1 / ARG2;<br />\
REG8 = ARG1 mod ARG2;\
<h3>Modyfikowane Flagi</h3>\
Flagi OF i CF są ustawiane na 1, gdy dzielnik to 0, w przeciwnym przypadku ustawiane na 0. Flagi SF, ZF i \
PF nie są modyfikowane.
cmp.summary=<h1>CMP</h1>\
Porównuje pierwszy źródłowy argument z drugim źródłowym argumentem i ustawia flagi w zależności \
od wyniku porównania. Porównanie jest wykonywane przez odejmowanie drugiego argumentu od \
pierwszego w podobny sposób jak w instrukcji SUB, jednak wynik nie jest nigdzie zapisywany. Pierwszy \
argument może być wyłącznie rejestrem. Drugi argument może być rejestrem albo miejscem w pamięci. \
Warunki w instrukcjach skoku odnoszą się do wyniku porównania instrukcji CMP.\
<h3>Operacja</h3>\
TEMP = ARG1 – ARG2;\
<br />\
MODIFY_FLAGS;\
<br />\
EIP = ADDRESS(ARG1);\
<h3>Modyfikowane Flagi</h3>\
Flagi OF, SF, ZF, CF i PF są ustawione w zależności od wyniku.
fadd.summary=<h1>FADD</h1>\
Dodaje pierwszy argument(wynikowy) do drugiego argumentu(źródłowy) a następnie przechowuje \
wynik w argumencie wynikowym. Wynikowy argument może być wyłącznie rejestrem \
zmiennoprzecinkowym. Źródłowy argument może być rejestrem zmiennoprzecinkowym albo miejscem \
w pamięci.\
<h3>Operacja</h3>\
ARG1 = ARG1 + ARG2;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fsub.summary=<h1>FSUB</h1>\
Odejmuje drugi argument(źródłowy) do pierwszego argumentu(wynikowy) a następnie przechowuje \
wynik w argumencie wynikowym. Wynikowy argument może być wyłącznie rejestrem \
zmiennoprzecinkowym. Źródłowy argument może być rejestrem zmiennoprzecinkowym albo miejscem \
w pamięci.\
<h3>Operacja</h3>\
ARG1 = ARG1 - ARG2;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fmul.summary=<h1>FMUL</h1>\
Mnoży pierwszy argument(wynikowy) przez drugi argument(źródłowy) a następnie przechowuje wynik w \
argumencie wynikowym. Wynikowy argument może być wyłącznie rejestrem zmiennoprzecinkowym. \
Źródłowy argument może być rejestrem zmiennoprzecinkowym albo miejscem w pamięci.\
<h3>Operacja</h3>\
ARG1 = ARG1 · ARG2;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fdiv.summary=<h1>FDIV</h1>\
Dzieli pierwszy argument(wynikowy) przez drugi argument(źródłowy) a następnie przechowuje wynik w \
argumencie wynikowym. Wynikowy argument może być wyłącznie rejestrem zmiennoprzecinkowym. \
Źródłowy argument może być rejestrem zmiennoprzecinkowym albo miejscem w pamięci.\
<h3>Operacja</h3>\
ARG1 = ARG1 / ARG2;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fcmp.summary=<h1>FCMP</h1>\
Porównuje pierwszy argument źródłowy z drugim i ustawia flagi ZF, CF i PF w zależności od wyniku (patrz \
tabela poniżej). Flagi ZF i CF są ustawiane podobnie jak gdyby użyta była instrukcja CMP dla liczb \
całkowitych bez znaku (Instrukcje JA, JE i JB powinny zostać użyte do sprawdzenia warunku). Flaga CF jest \
ustawiana, gdy jeden z argumentów nie jest liczbą. Wynikowy argument może być wyłącznie rejestrem \
zmiennoprzecinkowym. Źródłowy argument może być rejestrem zmiennoprzecinkowym albo miejscem \
w pamięci. Znak 0.0 jest ignorowany, więc +0.0 jest równe -0.0.\
<br />\
<table >\
<tbody>\
<tr>\
<td> Warunek </td>\
<td> ZF </td>\
<td> CF </td>\
<td> PF </td>\
</tr>\
<tr>\
<td> ARG1 &gt; ARG2 </td>\
<td> 0 </td>\
<td> 0 </td>\
<td> 0 </td>\
</tr>\
<tr>\
<td> ARG1 &lt; ARG2 </td>\
<td> 0 </td>\
<td> 1 </td>\
<td> 0 </td>\
</tr>\
<tr>\
<td> ARG1 = ARG2 </td>\
<td> 1 </td>\
<td> 0 </td>\
<td> 0 </td>\
</tr>\
<tr>\
<td> ARG1 ? ARG2 </td>\
<td> 1 </td>\
<td> 1 </td>\
<td> 1 </td>\
</tr>\
</tbody>\
</table>\
<h3>Operacja</h3>\
CASE(RELATION)<br />\
&nbsp;&nbsp;&nbsp;&nbsp;ARG1 &lt; ARG2: ZF=0, CF=0, PF=0;<br />\
&nbsp;&nbsp;&nbsp;&nbsp;ARG1 &gt; ARG2: ZF=0, CF=1, PF=0;<br />\
&nbsp;&nbsp;&nbsp;&nbsp;ARG1 = ARG2: ZF=1, CF=0, PF=0;<br />\
&nbsp;&nbsp;&nbsp;&nbsp;DEFAULT: ZF=1, CF=1, PF=1;\
<h3>Modyfikowane Flagi</h3>\
Flagi OF, SF nie są modyfikowane. Dla flag ZF, CF, PF patrz tabela wyżej.
neg.summary=<h1>NEG</h1>\
Zamienia wynikowy argument jego uzupełnieniem w U2. (Ta operacja jest równoważna z odjęciem \
argumentu od zera) Argumentem może być rejestr lub miejsce w pamięci.\
<h3>Operacja</h3>\
IF(ARG1 = 0)<br />\
&nbsp;&nbsp;&nbsp;&nbsp;THEN: CF=0;<br />\
&nbsp;&nbsp;&nbsp;&nbsp;ELSE: CF=1;<br />\
FI;<br />\
ARG1 = -ARG1;\
<h3>Modyfikowane Flagi</h3>\
Flaga CF nie jest modyfikowana. Flagi OF, SF, ZF i PF są ustawione w zależności od wyniku.
inc.summary=<h1>INC</h1>\
Dodaje jeden do argumentu(wynikowy), jednocześnie zachowując stan flagi CF. Wynikowy argument \
może być rejestrem albo miejscem w pamięci. Instrukcja pozwala zwiększenie licznika pętli bez \
modyfikacji flagi CF.(Żeby zwiększyć licznik z modyfikacją flagi CF należy użyć odpowiednio instrukcji \
ADD)\
<h3>Operacja</h3>\
ARG1 = ARG1 + 1;\
<h3>Modyfikowane Flagi</h3>\
Flaga CF nie jest modyfikowana. Flagi OF, SF, ZF i PF są ustawione w zależności od wyniku.
dec.summary=<h1>DEC</h1>\
Odejmuje jeden od argumentu(wynikowy), jednocześnie zachowując stan flagi CF. Wynikowy argument \
może być rejestrem albo miejscem w pamięci. Instrukcja pozwala zmniejszenie licznika pętli bez \
modyfikacji flagi CF.(Żeby zmniejszyć licznik z modyfikacją flagi CF należy użyć odpowiednio instrukcji \
SUB)\
<h3>Operacja</h3>\
ARG1 = ARG1 - 1;\
<h3>Modyfikowane Flagi</h3>\
Flaga CF nie jest modyfikowana. Flagi OF, SF, ZF i PF są ustawione w zależności od wyniku.
fsqrt.summary=<h1>FSQRT</h1>\
Oblicza wartość pierwiastka kwadratowego podanego argumentu. Argument może być wyłącznie \
rejestrem zmiennoprzecinkowym.\
<h3>Operacja</h3>\
ARG1 = SQRT(ARG1);\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fabs.summary=<h1>FABS</h1>\
Zeruje bit znaku pierwszego argumentu tworząc tym samym wartość bezwzględną. Argumentem może \
być wyłącznie rejestr zmiennoprzeicnkowy.\
<h3>Operacja</h3>\
ARG1 = |ARG1|;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fsin.summary=<h1>FSIN</h1>\
Oblicza przybliżoną wartość sinusa kąta podanego argumentu. Argument musi być podany w radianach i \
może być wyłącznie rejestrem zmiennoprzecinkowym.\
<h3>Operacja</h3>\
ARG1 = SIN(ARG1);\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fcos.summary=<h1>FCOS</h1>\
Oblicza przybliżoną wartość cosinusa kąta podanego argumentu. Argument musi być podany w \
radianach i może być wyłącznie rejestrem zmiennoprzecinkowym.\
<h3>Operacja</h3>\
ARG1 = COS(ARG1);\
<h3>Modyfikowane Flagi</h3>\
Żadne.
ftan.summary=<h1>FTAN</h1>\
Oblicza przybliżoną wartość tangensa kąta podanego argumentu. Argument musi być podany w \
radianach i może być wyłącznie rejestrem zmiennoprzecinkowym.\
<h3>Operacja</h3>\
ARG1 = TAN(ARG1);\
<h3>Modyfikowane Flagi</h3>\
Żadne.
fxam.summary=<h1>FXAM</h1>\
Bada zawartość argumentu źródłowego i ustawia odpowiednio flagi ZF, CF i PF. Ustawienie flag \
odpowiada odpowiednim klasom(patrz tabela niżej). Flaga SF jest zawsze ustawiana względem bitu \
znaku liczby. Argumentem może być rejestr zmiennoprzecinkowy lub miejsce w pamięci.<br />\
<table >\
<tbody>\
<tr>\
<td> Klasa </td>\
<td> ZF </td>\
<td> CF </td>\
<td> PF </td>\
</tr>\
<tr>\
<td> Nieskończoność </td>\
<td> 0 </td>\
<td> 1 </td>\
<td> 1 </td>\
</tr>\
<tr>\
<td> Nie-liczba </td>\
<td> 0 </td>\
<td> 1 </td>\
<td> 0 </td>\
</tr>\
<tr>\
<td> Zero </td>\
<td> 1 </td>\
<td> 0 </td>\
<td> 0 </td>\
</tr>\
<tr>\
<td> Nieznoramlizowana </td>\
<td> 1 </td>\
<td> 0 </td>\
<td> 1 </td>\
</tr>\
<tr>\
<td> Zwykła wartość </td>\
<td> 0 </td>\
<td> 0 </td>\
<td> 1 </td>\
</tr>\
<tr>\
<td> Niewspierana wartość </td>\
<td> 0 </td>\
<td> 0 </td>\
<td> 0 </td>\
</tr>\
</tbody>\
</table>\
<h3>Operacja</h3>\
CASE(CLASS)<br />\
&nbsp;&nbsp;&nbsp;&nbsp;INFINITY: ZF=0, CF=1, PF=1;<br />\
&nbsp;&nbsp;&nbsp;&nbsp;NAN: ZF=0, CF=1, PF=0;<br />\
&nbsp;&nbsp;&nbsp;&nbsp;ZERO: ZF=1, CF=0, PF=0;<br />\
&nbsp;&nbsp;&nbsp;&nbsp;SUBNORMAL: ZF=1, CF=0, PF=1;<br />\
&nbsp;&nbsp;&nbsp;&nbsp;FINITE: ZF=0, CF=0, PF=1;<br />\
&nbsp;&nbsp;&nbsp;&nbsp;DEFAULT: ZF=0, CF=0, PF=0;<br />\
SF = 0x80000000 & ARG1;\
<h3>Modyfikowane Flagi</h3>\
Flaga OF, nie jest modyfikowana. Flaga SF jest ustawiana w zależności od znaku. Dla flag ZF, CF, PF patrz \
tabela wyżej.
ftst.summary=<h1>FTST</h1>\
Porównuje pierwszy argument źródłowy z wartością 0.0 i ustawia flagi ZF, CF i PF w zależności od wyniku \
(patrz tabela poniżej). Flagi ZF i CF są ustawiane podobnie jak gdyby użyta była instrukcja CMP dla liczb \
całkowitych bez znaku (Instrukcje JA, JE i JB powinny zostać użyte do sprawdzenia warunku). Flaga CF jest \
ustawiana, gdy argument nie jest liczbą. Źródłowy argument może być rejestrem zmiennoprzecinkowym \
albo miejscem w pamięci. Znak 0.0 jest ignorowany, więc +0.0 jest równe -0.0.\
<br />\
<table >\
<tbody>\
<tr>\
<td> Warunek </td>\
<td> ZF </td>\
<td> CF </td>\
<td> PF </td>\
</tr>\
<tr>\
<td> ARG1 &gt; 0.0 </td>\
<td> 0 </td>\
<td> 0 </td>\
<td> 0 </td>\
</tr>\
<tr>\
<td> ARG1 &lt; 0.0 </td>\
<td> 0 </td>\
<td> 1 </td>\
<td> 0 </td>\
</tr>\
<tr>\
<td> ARG1 = 0.0 </td>\
<td> 1 </td>\
<td> 0 </td>\
<td> 0 </td>\
</tr>\
<tr>\
<td> ARG1 ? ARG2 </td>\
<td> 1 </td>\
<td> 1 </td>\
<td> 1 </td>\
</tr>\
</tbody>\
</table>\
<h3>Operacja</h3>\
CASE(RELATION)<br />\
&nbsp;&nbsp;&nbsp;&nbsp;ARG1 &lt; 0.0: ZF=0, CF=0, PF=0;<br />\
&nbsp;&nbsp;&nbsp;&nbsp;ARG1 &gt; 0.0: ZF=0, CF=1, PF=0;<br />\
&nbsp;&nbsp;&nbsp;&nbsp;ARG1 = 0.0: ZF=1, CF=0, PF=0;<br />\
&nbsp;&nbsp;&nbsp;&nbsp;DEFAULT: ZF=1, CF=1, PF=1;\
<h3>Modyfikowane Flagi</h3>\
Flagi OF, SF nie są modyfikowane. Dla flag ZF, CF, PF patrz tabela wyżej.
and.summary=<h1>AND</h1>\
Wykonuje bitową koniunkcję pierwszego argumentu(wynikowy) i drugiego argumentu(źródłowy) a \
następnie przechowuje wynik w argumencie wynikowym. Wynikowy argument może być wyłącznie \
rejestrem; źródłowy argument może być rejestrem albo miejscem w pamięci. Każdy bit wyniku ustawiany \
jest wartością 1 jeżeli w obu wynikowym i źródłowym argumencie odpowiedni bit miał wartość 1; w \
przeciwnym przypadku ustawiany jest wartością 0.\
<h3>Operacja</h3>\
ARG1 = ARG1 and ARG2;\
<h3>Modyfikowane Flagi</h3>\
Flagi OF i CF są ustawiane na 0; Flagi SF, ZF, PF są ustawiane w zależności od wyniku.
or.summary=<h1>OR</h1>\
Wykonuje bitową alternatywę pierwszego argumentu(wynikowy) i drugiego argumentu(źródłowy) a \
następnie przechowuje wynik w argumencie wynikowym. Wynikowy argument może być wyłącznie \
rejestrem; źródłowy argument może być rejestrem albo miejscem w pamięci. Każdy bit wyniku ustawiany \
jest wartością 1 jeżeli w wynikowym lub źródłowym argumencie odpowiedni bit miał wartość 1; w \
przeciwnym przypadku ustawiany jest wartością 0.\
<h3>Operacja</h3>\
ARG1 = ARG1 or ARG2;\
<h3>Modyfikowane Flagi</h3>\
Flagi OF i CF są ustawiane na 0; Flagi SF, ZF, PF są ustawiane w zależności od wyniku.
xor.summary=<h1>XOR</h1>\
Wykonuje bitową alternatywę pierwszego argumentu(wynikowy) i drugiego argumentu(źródłowy) a \
następnie przechowuje wynik w argumencie wynikowym. Wynikowy argument może być wyłącznie \
rejestrem; źródłowy argument może być rejestrem albo miejscem w pamięci. Każdy bit wyniku ustawiany \
jest wartością 1 jeżeli w wynikowym albo źródłowym argumencie odpowiedni bit miał wartość 1; w \
przeciwnym przypadku ustawiany jest wartością 0.\
<h3>Operacja</h3>\
ARG1 = ARG1 xor ARG2;\
<h3>Modyfikowane Flagi</h3>\
Flagi OF i CF są ustawiane na 0; Flagi SF, ZF, PF są ustawiane w zależności od wyniku.
test.summary=<h1>TEST</h1>\
Wykonuje bitową koniunkcję pierwszego argumentu(źródłowy) i drugiego argumentu(źródłowy), wynik \
nie jest nigdzie zapisywany, zmieniają się wyłącznie flagi. Pierwszy argument może być wyłącznie \
rejestrem. Drugi argument może być rejestrem albo miejscem w pamięci. Każdy bit wyniku ustawiany \
jest wartością 1 jeżeli w obu wynikowym i źródłowym argumencie odpowiedni bit miał wartość 1; w \
przeciwnym przypadku ustawiany jest wartością 0.\
<h3>Operacja</h3>\
TEMP = ARG1 and ARG2;\
<h3>Modyfikowane Flagi</h3>\
Flagi OF i CF są ustawiane na 0; Flagi SF, ZF, PF są ustawiane w zależności od wyniku.
not.summary=<h1>NOT</h1>\
Wykonuje bitową negację argumentu wynikowego, wynik jest zapisywany w argumencie wynikowym. \
Argument wynikowy może być rejestrem albo miejscem w pamięci. Każdy bit wyniku ustawiany jest \
wartością 1 jeżeli w wynikowym argumencie odpowiedni bit miał wartość 0; w przeciwnym przypadku \
ustawiany jest wartością 0.\
<h3>Operacja</h3>\
ARG1 = not ARG1;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
shr.summary=<h1>SHR</h1>\
Przesuwa w prawo bity wartości podanej w pierwszym argumencie(wynikowy) o wartość podaną w \
drugim argumencie(źródłowy). Wynikowy argument może być wyłącznie rejestrem; źródłowy argument \
może być rejestrem albo miejscem w pamięci. Bity z lewej strony są zerami. Jedynie pierwsze 5 bitów \
argumentu źródłowego brane są pod uwagę.\
<h3>Operacja</h3>\
ARG1 = ARG1 >>> ARG2\
<h3>Modyfikowane Flagi</h3>\
Flagi OF i CF są ustawiane na 0; Flagi SF, ZF, PF są ustawiane w zależności od wyniku.
shl.summary=<h1>SHL</h1>\
Przesuwa w lewo bity wartości podanej w pierwszym argumencie(wynikowy) o wartość podaną w\
drugim argumencie(źródłowy). Wynikowy argument może być wyłącznie rejestrem; źródłowy argument\
może być rejestrem albo miejscem w pamięci. Bity z prawej strony są uzupełniane zerami. Jedynie\
pierwsze 5 bitów argumentu źródłowego brane są pod uwagę.<br />\
Instrukcje SAL i SHL wykonują dokładnie te same operacje.\
<h3>Operacja</h3>\
ARG1 = ARG1 << ARG2\
<h3>Modyfikowane Flagi</h3>\
Flagi OF i CF są ustawiane na 0; Flagi SF, ZF, PF są ustawiane w zależności od wyniku.
sar.summary=<h1>SAR</h1>\
Przesuwa w prawo bity wartości podanej w pierwszym argumencie(wynikowy) o wartość podaną w \
drugim argumencie(źródłowy). Wynikowy argument może być wyłącznie rejestrem; źródłowy argument \
może być rejestrem albo miejscem w pamięci. Bity z lewej strony są uzupełniane znakiem argumentu \
wynikowego. Jedynie pierwsze 5 bitów argumentu źródłowego brane są pod uwagę.\
<h3>Operacja</h3>\
ARG1 = ARG1 >> ARG2\
<h3>Modyfikowane Flagi</h3>\
Flagi OF i CF są ustawiane na 0; Flagi SF, ZF, PF są ustawiane w zależności od wyniku.
sal.summary=<h1>SAL</h1>\
Przesuwa w lewo bity wartości podanej w pierwszym argumencie(wynikowy) o wartość podaną w\
drugim argumencie(źródłowy). Wynikowy argument może być wyłącznie rejestrem; źródłowy argument\
może być rejestrem albo miejscem w pamięci. Bity z prawej strony są uzupełniane zerami. Jedynie\
pierwsze 5 bitów argumentu źródłowego brane są pod uwagę.<br />\
Instrukcje SAL i SHL wykonują dokładnie te same operacje.\
<h3>Operacja</h3>\
ARG1 = ARG1 << ARG2\
<h3>Modyfikowane Flagi</h3>\
Flagi OF i CF są ustawiane na 0; Flagi SF, ZF, PF są ustawiane w zależności od wyniku.
ror.summary=<h1>ROR</h1>\
Przesuwa(obraca) w prawo bity wartości podanej w pierwszym argumencie(wynikowy) o wartość \
podaną w drugim argumencie(źródłowy). Wynikowy argument może być wyłącznie rejestrem; źródłowy \
argument może być rejestrem albo miejscem w pamięci. Bity z lewej strony są uzupełniane bitami \
przesuniętymi z prawej strony. Jedynie pierwsze 5 bitów argumentu źródłowego brane są pod uwagę.\
<h3>Operacja</h3>\
ARG1 = ROTATE_RIGHT(ARG1, ARG2);\
<h3>Modyfikowane Flagi</h3>\
Flagi OF i CF są ustawiane na 0; Flagi SF, ZF, PF są ustawiane w zależności od wyniku.
rol.summary=<h1>ROL</h1>\
Przesuwa(obraca) w lewo bity wartości podanej w pierwszym argumencie(wynikowy) o wartość podaną \
w drugim argumencie(źródłowy). Wynikowy argument może być wyłącznie rejestrem; źródłowy \
argument może być rejestrem albo miejscem w pamięci. Bity z prawej strony są uzupełniane bitami \
przesuniętymi z lewej strony. Jedynie pierwsze 5 bitów argumentu źródłowego brane są pod uwagę.\
<h3>Operacja</h3>\
ARG1 = ROTATE_LEFT(ARG1, ARG2);\
<h3>Modyfikowane Flagi</h3>\
Flagi OF i CF są ustawiane na 0; Flagi SF, ZF, PF są ustawiane w zależności od wyniku.
jmp.summary=<h1>JMP</h1>\
Wykonuje skok do miejsca w pamięci podanego w argumencie. Argumentem może być wyłącznie \
miejsce w pamięci.\
<h3>Operacja</h3>\
EIP = ADDRESS(ARG1);\
<h3>Modyfikowane Flagi</h3>\
Żadne.
je.summary=<h1>JE</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(ZF=1), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF ZF=1<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jz.summary=<h1>JZ</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(ZF=1), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF ZF=1<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jne.summary=<h1>JNE</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(ZF=0), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF ZF=0<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jnz.summary=<h1>JNZ</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(ZF=0), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF ZF=0<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jg.summary=<h1>JG</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(ZF=0 i \
SF=OF), to wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest \
spełniony to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po \
instrukcji skoku. Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF ZF=0 i SF=OF<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jnle.summary=<h1>JNLE</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(ZF=0 i \
SF=OF), to wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest \
spełniony to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po \
instrukcji skoku. Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF ZF=0 i SF=OF<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jge.summary=<h1>JGE</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(SF=OF), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF SF=OF<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jnl.summary=<h1>JNL</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(SF=OF), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF SF=OF<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jl.summary=<h1>JL</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(SF!=OF), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF SF!=OF<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jnge.summary=<h1>JNGE</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(SF!=OF), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF SF!=OF<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jle.summary=<h1>JLE</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(ZF=1 lub SF! \
=OF), to wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest \
spełniony to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po \
instrukcji skoku. Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF ZF=1 lub SF!=OF<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jng.summary=<h1>JNG</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(ZF=1 lub SF! \
=OF), to wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest \
spełniony to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po \
instrukcji skoku. Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF ZF=1 lub SF!=OF<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
ja.summary=<h1>JA</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(CF=0 i \
ZF=0), to wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest \
spełniony to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po \
instrukcji skoku. Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF CF=0 i ZF=0<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jnbe.summary=<h1>JNBE</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(CF=0 i \
ZF=0), to wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest \
spełniony to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po \
instrukcji skoku. Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF CF=0 i ZF=0<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jae.summary=<h1>JAE</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(CF=0), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF CF=0<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jnb.summary=<h1>JNB</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(CF=0), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF CF=0<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jnc.summary=<h1>JNC</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(CF=0), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF CF=0<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jb.summary=<h1>JB</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(CF=1), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF CF=1<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jnae.summary=<h1>JNAE</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(CF=1), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF CF=1<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jc.summary=<h1>JC</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(CF=1), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF CF=1<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jbe.summary=<h1>JBE</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(CF=1 lub \
ZF=1), to wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest \
spełniony to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po \
instrukcji skoku. Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF CF=1 lub ZF=1<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jna.summary=<h1>JNA</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(CF=1 lub \
ZF=1), to wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest \
spełniony to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po \
instrukcji skoku. Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF CF=1 lub ZF=1<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jo.summary=<h1>JO</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(OF=1), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF OF=1<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jno.summary=<h1>JNO</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(OF=0), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF OF=0<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
js.summary=<h1>JS</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(SF=1), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF SF=1<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jns.summary=<h1>JNS</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(SF=0), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF SF=0<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jp.summary=<h1>JP</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(PF=1), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF PF=1<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
jnp.summary=<h1>JNP</h1>\
Sprawdza czy flagi rejestru flag są w ustalonym stanie, jeśli tak, czyli warunek jest spełniony(PF=0), to \
wykonywany jest skok do miejsca w pamięci podanego w argumencie. Jeśli warunek nie jest spełniony \
to skok nie jest wykonywany, a egzekucja programu kontynuuje sekwencyjnie zaraz po instrukcji skoku. \
Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
IF PF=0<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG1);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
loop.summary=<h1>LOOP</h1>\
Z każdym wywołanie funkcji LOOP pierwszy argument(licznik) jest zmniejszany o jeden, a następnie \
wartość w pierwszym argumencie porównywana jest z zerem. Jeżeli licznik jest różny od zera, to \
wykonywany jest skok w miejsce sprecyzowane w drugim argumencie. Jeżeli licznik wynosi 0 skok nie \
jest wykonywany, egzekucja kontynuuje sekwencyjnie.\
<h3>Operacja</h3>\
ARG1 = ARG1 – 1;<br />\
IF(ARG1=0)<br />\
&nbsp;&nbsp;&nbsp;&nbsp;EIP = ADDRESS(ARG2);<br />\
FI;\
<h3>Modyfikowane Flagi</h3>\
Żadne.
call.summary=<h1>CALL</h1>\
Zapisuje adres następnej po tej instrukcji(rejestr EIP) na stosie(dla późniejszego powrotu instrukcją RET), \
następnie skacze w miejsce wskazane w argumencie źródłowym, wskazującym na pierwszą instrukcję \
procedury. Argumentem może być wyłącznie miejsce w pamięci.\
<h3>Operacja</h3>\
STACK.PUSH(EIP);\
<br />\
EIP = ADDRESS(ARG1);\
<h3>Modyfikowane Flagi</h3>\
Żadne.
exit.summary=<h1>EXIT</h1>\
Kończy działanie komputera.\
<h3>Modyfikowane Flagi</h3>\
Żadne.
ret.summary=<h1>RET</h1>\
Skacze do miejsca w pamięci zlokalizowanego na szczycie stosu. Adres na szczycie zazwyczaj jest \
umieszczony przez wywołanie instrukcji CALL. Adres ten jest wtedy adresem następnej instrukcji po \
instrukcji CALL.\
<h3>Operacja</h3>\
EIP = STACK.POP();\
<h3>Modyfikowane Flagi</h3>\
Żadne.
dc.summary=Zadeklaruj stałą, miejsce w pamięci będzie zarezerwowane, wymagane będzie podanie tej \
stałej w deklaracji, która zostanie umieszczona w pamięci jeszcze przed wykonaniem programu.<br />\
Deklaracja jest postaci:<br />\
[ETYKIETA] <KOD_DEKLARACJI> [LICZBA*]<TYP_ZMIENNEJ>[(WARTOŚĆ)]<br />\
• LICZBA oznacza ile kopii zmiennej trzeba zarezerwować w pamięci, domyślnie 1 kopia jeżeli nie \
zostało to podane<br />\
• TYP_ZMIENNEJ oznacza jakiego typu będzie to zmienna;<br />\
• WARTOŚĆ jaka zostanie wpisana do pamięci w stosownym formacie zależnie od podanego typu; \
jeżeli kod deklaracji to DC podanie wartości jest obowiązkowe, jeżeli DS to podanie wartości jest \
niedozwolone;<br />
ds.summary=Zadeklaruj przestrzeń, miejsce w pamięci będzie zarezerwowane, ale nie zostanie tam \
umieszczona żadna wartość.<br />\
Deklaracja jest postaci:<br />\
[ETYKIETA] <KOD_DEKLARACJI> [LICZBA*]<TYP_ZMIENNEJ>[(WARTOŚĆ)]<br />\
• LICZBA oznacza ile kopii zmiennej trzeba zarezerwować w pamięci, domyślnie 1 kopia jeżeli nie \
zostało to podane<br />\
• TYP_ZMIENNEJ oznacza jakiego typu będzie to zmienna;<br />\
• WARTOŚĆ jaka zostanie wpisana do pamięci w stosownym formacie zależnie od podanego typu; \
jeżeli kod deklaracji to DC podanie wartości jest obowiązkowe, jeżeli DS to podanie wartości jest \
niedozwolone;<br />
float.summary=Liczba zmiennoprzecinkowa typu FLOAT. Zajmuje 4 bajty w pamięci.
integer.summary=Liczba całkowita typu INTEGER. Zajmuje 4 bajty w pamięci.
string.summary=Łańcuch znaków. Składa się z podanych znaków i automatycznie dodawanego bajtu o wartości 0.
char.summary=Liczba typu CHAR. Zajmuje 1 bajt w pamięci.
byte.summary=Liczba typu BYTE. Zajmuje 1 bajt w pamięci.